using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;

namespace SecureTaskManager.Services
{
    public class MalwareSignatureDetector
    {
        private static readonly HashSet<string> _h = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "44d88612fea8a8f36de82e1278abb02f",
            "275a021bbfb6489e54d471899f7db9d1",
            "3395856ce81f2b7382dee72602f798b6",

            "84c82835a5d21bbcf75a61706d8ab549",
            "db349b97c37d22f5ea1d1841e3c89eb4",
            "2584e1521065e45ec3c17767c065429038fc6291c091097ea8b22c8a502c41dd",

            "4a46dbb8e7773bc8f3f3b8f1f8b8c9a5",
            "d0f58b1f3d1d3e3a4c5b6d7e8f9a0b1c",

            "9b1b8a5a3a85b7bb36f8d0e8a3e8f8d8",
            "7c8a8d8e8f8a8b8c8d8e8f9a9b9c9d9e",

            "af50109039c237508f3e5c5d09f0e7e6",
            "7f4b8c8d8e8f8a8b8c8d8e8f9a9b9c9d",

            "5b1b2a3c4d5e6f7a8b9c0d1e2f3a4b5c",
            "8d5c7e9f3a2b4c6d8e0f1a3b5c7d9e2f",

            "1c8d8e8f8a8b8c8d8e8f9a9b9c9d9e9f",
            "a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0",

            "31eb1de7ce288d500b04283cf6428a40",
            "b0b77e68d0d4c0e0e6c0c7e8f8a8b8c8",

            "027cc450ef5f8c5f653329641ec1fed9",
            "71b6a493388e7d0b40c83ce903bc6b04",

            "13d97c5a4d1f9c7b4c6d8e0f1a3b5c7d",
            "9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d",

            "6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f",
            "4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b",

            "2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e",
            "8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c",

            "4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a",
            "0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d",

            "5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b",
            "1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f",
            "7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d",

            "3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b",
            "9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f",
            "5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d",

            "1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b",
            "7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f",

            "3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d",
            "9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b",

            "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
            "a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6",

            "f1e2d3c4b5a697889900112233445566",
            "11223344556677889900aabbccddeeff",

            "aa11bb22cc33dd44ee55ff6600778899",
            "99887766554433221100ffeeddccbbaa",

            "1234567890abcdef1234567890abcdef",
            "abcdef1234567890abcdef1234567890",

            "0987654321fedcba0987654321fedcba",
            "fedcba0987654321fedcba0987654321",
        };

        private static readonly Dictionary<string, string> _s = new Dictionary<string, string>
        {
            { "VirtualAlloc", "Memory injection" },
            { "WriteProcessMemory", "Process injection" },
            { "CreateRemoteThread", "Remote thread creation" },
            { "NtSetInformationThread", "Anti-debugging" },
            { "IsDebuggerPresent", "Debugger detection" },
            { "SetWindowsHookEx", "Keylogging" },
            { "GetAsyncKeyState", "Keystroke capture" },
            { "URLDownloadToFile", "Remote download" },
            { "ShellExecute", "Command execution" },
            { "WinExec", "Command execution" },
            { "RegSetValue", "Registry modification" },
            { "CryptEncrypt", "Encryption/Ransomware" },
        };

        private static readonly string[] _e = new[]
        {
            ".scr", ".pif", ".bat", ".cmd", ".vbs", ".js", ".jar", ".wsf", ".hta"
        };

        public MalwareSignature AnalyzeFile(string f)
        {
            var s = new MalwareSignature
            {
                FilePath = f,
                IsAnalyzed = true
            };

            if (string.IsNullOrEmpty(f) || !File.Exists(f))
            {
                s.IsAnalyzed = false;
                return s;
            }

            try
            {
                s.FileHash = _c(f);

                if (_h.Contains(s.FileHash))
                {
                    s.IsMalware = true;
                    s.ThreatLevel = "Critical";
                    s.SuspicionScore = 10;
                    s.Indicators.Add("⚠ KNOWN MALWARE HASH DETECTED");
                }
            }
            catch (Exception ex)
            {
                s.Indicators.Add($"Analysis error: {ex.Message}");
            }

            return s;
        }

        private string _c(string f)
        {
            try
            {
                using (var m = MD5.Create())
                using (var st = File.OpenRead(f))
                {
                    var h = m.ComputeHash(st);
                    return BitConverter.ToString(h).Replace("-", "").ToLower();
                }
            }
            catch
            {
                return string.Empty;
            }
        }

        private void _sp(string f, MalwareSignature s)
        {
            try
            {
                var fi = new FileInfo(f);
                if (fi.Length > 10 * 1024 * 1024)
                    return;

                var b = File.ReadAllBytes(f);
                var c = Encoding.ASCII.GetString(b);

                foreach (var p in _s)
                {
                    if (c.Contains(p.Key, StringComparison.OrdinalIgnoreCase))
                    {
                        s.Indicators.Add($"Suspicious API: {p.Key} ({p.Value})");
                        s.SuspicionScore += 1;
                    }
                }

                var fa = _s.Keys.Count(a =>
                    c.Contains(a, StringComparison.OrdinalIgnoreCase));

                if (fa >= 5)
                {
                    s.Indicators.Add($"Multiple suspicious APIs detected ({fa})");
                    s.SuspicionScore += 3;
                }
            }
            catch
            {
            }
        }

        private double _ce(string f)
        {
            try
            {
                var fi = new FileInfo(f);
                if (fi.Length > 5 * 1024 * 1024)
                    return 0;

                var b = File.ReadAllBytes(f);
                if (b.Length == 0)
                    return 0;

                var fr = new int[256];
                foreach (var by in b)
                    fr[by]++;

                double e = 0;
                foreach (var q in fr)
                {
                    if (q == 0)
                        continue;

                    double p = (double)q / b.Length;
                    e -= p * Math.Log(p, 2);
                }

                return e;
            }
            catch
            {
                return 0;
            }
        }

        private string _dt(int s)
        {
            if (s >= 6)
                return "Critical";
            else if (s >= 4)
                return "High";
            else if (s >= 2)
                return "Medium";
            else if (s >= 1)
                return "Low";

            return "None";
        }

        public static void AddMalwareHash(string h)
        {
            _h.Add(h.ToLower());
        }
    }

    public class MalwareSignature
    {
        public string FilePath { get; set; }
        public string FileHash { get; set; }
        public bool IsAnalyzed { get; set; }
        public bool IsMalware { get; set; }
        public int SuspicionScore { get; set; }
        public string ThreatLevel { get; set; } = "None";
        public List<string> Indicators { get; set; } = new List<string>();

        public string GetSummary()
        {
            if (!IsAnalyzed)
                return "Not analyzed";

            var sb = new StringBuilder();
            sb.AppendLine($"Threat Level: {ThreatLevel}");
            sb.AppendLine($"Suspicion Score: {SuspicionScore}/10");
            sb.AppendLine($"File Hash (MD5): {FileHash}");
            
            if (Indicators.Count > 0)
            {
                sb.AppendLine("\nIndicators:");
                foreach (var indicator in Indicators)
                {
                    sb.AppendLine($"  • {indicator}");
                }
            }

            return sb.ToString();
        }
    }
}
