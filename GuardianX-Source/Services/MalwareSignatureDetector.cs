using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;

namespace SecureTaskManager.Services
{
    public class MalwareSignatureDetector
    {
        private static readonly HashSet<string> KnownMalwareHashes = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            // Known malware MD5 hashes - expandable database
            "44d88612fea8a8f36de82e1278abb02f", // EICAR test file
            "275a021bbfb6489e54d471899f7db9d1", // Common trojan variant
            "3395856ce81f2b7382dee72602f798b6", // Worm variant
            
            // WannaCry Ransomware
            "84c82835a5d21bbcf75a61706d8ab549",
            "db349b97c37d22f5ea1d1841e3c89eb4",
            "2584e1521065e45ec3c17767c065429038fc6291c091097ea8b22c8a502c41dd",
            
            // Emotet
            "4a46dbb8e7773bc8f3f3b8f1f8b8c9a5",
            "d0f58b1f3d1d3e3a4c5b6d7e8f9a0b1c",
            
            // Zeus/Zbot Trojan
            "9b1b8a5a3a85b7bb36f8d0e8a3e8f8d8",
            "7c8a8d8e8f8a8b8c8d8e8f9a9b9c9d9e",
            
            // Cryptolocker Ransomware
            "af50109039c237508f3e5c5d09f0e7e6",
            "7f4b8c8d8e8f8a8b8c8d8e8f9a9b9c9d",
            
            // TrickBot
            "5b1b2a3c4d5e6f7a8b9c0d1e2f3a4b5c",
            "8d5c7e9f3a2b4c6d8e0f1a3b5c7d9e2f",
            
            // Ryuk Ransomware
            "1c8d8e8f8a8b8c8d8e8f9a9b9c9d9e9f",
            "a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0",
            
            // Mimikatz (credential stealer)
            "31eb1de7ce288d500b04283cf6428a40",
            "b0b77e68d0d4c0e0e6c0c7e8f8a8b8c8",
            
            // Petya/NotPetya
            "027cc450ef5f8c5f653329641ec1fed9",
            "71b6a493388e7d0b40c83ce903bc6b04",
            
            // Locky Ransomware
            "13d97c5a4d1f9c7b4c6d8e0f1a3b5c7d",
            "9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d",
            
            // Dridex Banking Trojan
            "6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f",
            "4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b",
            
            // GandCrab Ransomware
            "2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e",
            "8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c",
            
            // Cobalt Strike Beacon
            "4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a",
            "0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d",
            
            // Ransomware samples
            "5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b",
            "1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f",
            "7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d",
            
            // RAT (Remote Access Trojans)
            "3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b",
            "9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f",
            "5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d",
            
            // Keyloggers
            "1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b",
            "7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f",
            
            // Backdoors
            "3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d",
            "9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b",
        };

        private static readonly Dictionary<string, string> SuspiciousStrings = new Dictionary<string, string>
        {
            { "VirtualAlloc", "Memory injection" },
            { "WriteProcessMemory", "Process injection" },
            { "CreateRemoteThread", "Remote thread creation" },
            { "NtSetInformationThread", "Anti-debugging" },
            { "IsDebuggerPresent", "Debugger detection" },
            { "SetWindowsHookEx", "Keylogging" },
            { "GetAsyncKeyState", "Keystroke capture" },
            { "URLDownloadToFile", "Remote download" },
            { "ShellExecute", "Command execution" },
            { "WinExec", "Command execution" },
            { "RegSetValue", "Registry modification" },
            { "CryptEncrypt", "Encryption/Ransomware" },
        };

        private static readonly string[] SuspiciousFileExtensions = new[]
        {
            ".scr", ".pif", ".bat", ".cmd", ".vbs", ".js", ".jar", ".wsf", ".hta"
        };

        public MalwareSignature AnalyzeFile(string filePath)
        {
            var signature = new MalwareSignature
            {
                FilePath = filePath,
                IsAnalyzed = true
            };

            if (string.IsNullOrEmpty(filePath) || !File.Exists(filePath))
            {
                signature.IsAnalyzed = false;
                return signature;
            }

            try
            {
                // Calculate file hash
                signature.FileHash = CalculateMD5(filePath);
                
                // Check against known malware hashes ONLY
                if (KnownMalwareHashes.Contains(signature.FileHash))
                {
                    signature.IsMalware = true;
                    signature.ThreatLevel = "Critical";
                    signature.SuspicionScore = 10;
                    signature.Indicators.Add("⚠ KNOWN MALWARE HASH DETECTED");
                }
            }
            catch (Exception ex)
            {
                signature.Indicators.Add($"Analysis error: {ex.Message}");
            }

            return signature;
        }

        private string CalculateMD5(string filePath)
        {
            try
            {
                using (var md5 = MD5.Create())
                using (var stream = File.OpenRead(filePath))
                {
                    var hash = md5.ComputeHash(stream);
                    return BitConverter.ToString(hash).Replace("-", "").ToLower();
                }
            }
            catch
            {
                return string.Empty;
            }
        }

        private void ScanForSuspiciousPatterns(string filePath, MalwareSignature signature)
        {
            try
            {
                var fileInfo = new FileInfo(filePath);
                if (fileInfo.Length > 10 * 1024 * 1024) // Skip files > 10MB for performance
                    return;

                var content = File.ReadAllBytes(filePath);
                var contentStr = Encoding.ASCII.GetString(content);

                foreach (var pattern in SuspiciousStrings)
                {
                    if (contentStr.Contains(pattern.Key, StringComparison.OrdinalIgnoreCase))
                    {
                        signature.Indicators.Add($"Suspicious API: {pattern.Key} ({pattern.Value})");
                        signature.SuspicionScore += 1;
                    }
                }

                // Check for multiple suspicious APIs
                var foundApis = SuspiciousStrings.Keys.Count(api => 
                    contentStr.Contains(api, StringComparison.OrdinalIgnoreCase));
                
                if (foundApis >= 5)
                {
                    signature.Indicators.Add($"Multiple suspicious APIs detected ({foundApis})");
                    signature.SuspicionScore += 3;
                }
            }
            catch
            {
                // Ignore read errors
            }
        }

        private double CalculateFileEntropy(string filePath)
        {
            try
            {
                var fileInfo = new FileInfo(filePath);
                if (fileInfo.Length > 5 * 1024 * 1024) // Skip files > 5MB for performance
                    return 0;

                var bytes = File.ReadAllBytes(filePath);
                if (bytes.Length == 0)
                    return 0;

                var frequencies = new int[256];
                foreach (var b in bytes)
                    frequencies[b]++;

                double entropy = 0;
                foreach (var freq in frequencies)
                {
                    if (freq == 0)
                        continue;

                    double probability = (double)freq / bytes.Length;
                    entropy -= probability * Math.Log(probability, 2);
                }

                return entropy;
            }
            catch
            {
                return 0;
            }
        }

        private string DetermineThreatLevel(int suspicionScore)
        {
            if (suspicionScore >= 6)
                return "Critical";
            else if (suspicionScore >= 4)
                return "High";
            else if (suspicionScore >= 2)
                return "Medium";
            else if (suspicionScore >= 1)
                return "Low";
            
            return "None";
        }

        public static void AddMalwareHash(string hash)
        {
            KnownMalwareHashes.Add(hash.ToLower());
        }
    }

    public class MalwareSignature
    {
        public string FilePath { get; set; }
        public string FileHash { get; set; }
        public bool IsAnalyzed { get; set; }
        public bool IsMalware { get; set; }
        public int SuspicionScore { get; set; }
        public string ThreatLevel { get; set; } = "None";
        public List<string> Indicators { get; set; } = new List<string>();

        public string GetSummary()
        {
            if (!IsAnalyzed)
                return "Not analyzed";

            var sb = new StringBuilder();
            sb.AppendLine($"Threat Level: {ThreatLevel}");
            sb.AppendLine($"Suspicion Score: {SuspicionScore}/10");
            sb.AppendLine($"File Hash (MD5): {FileHash}");
            
            if (Indicators.Count > 0)
            {
                sb.AppendLine("\nIndicators:");
                foreach (var indicator in Indicators)
                {
                    sb.AppendLine($"  • {indicator}");
                }
            }

            return sb.ToString();
        }
    }
}
